use std::slice::from_raw_parts;
use std::convert::TryInto;

use nalegbra_numpy::matrix_slice_from_numpy;
use nalgebra::{MatrixSlice, U1, Dynamic};
use pyo3::prelude::*;
use pyo3::wrap_pyfunction;
use kiss3d::nalgebra::DVector;

const ITEMSIZE: usize = 16;  // bytes

pub type ArrivalTimes = DVector<u64>;

pub struct ToBeDisplayed {
    pub data0: ArrivalTimes,
    pub data1: Option<ArrivalTimes>,
    pub data2: Option<ArrivalTimes>,
    pub data3: Option<ArrivalTimes>,
    pub lines: ArrivalTimes,
    pub planes: Option<ArrivalTimes>,
}

impl ToBeDisplayed {
    pub fn new(data0: ArrivalTimes, data1: Option<ArrivalTimes>, data2: Option<ArrivalTimes>, data3: Option<ArrivalTimes>, lines: ArrivalTimes, planes: Option<ArrivalTimes>) -> Self {
        Self { data0, data1, data2, data3, lines, planes }
    }
}


#[derive(Debug, Clone)]
pub struct FrameSize {
    rows: u16,
    columns: u16,
    depth: Option<u16>,
}

impl FrameSize {
    pub fn new(rows: u16, columns: u16, depth: Option<u16>) -> Self {
        FrameSize {rows, columns, depth}
    }

}

impl Default for FrameSize {
    fn default() -> Self {
        Self::new(256, 256, Some(100))
    }
}

// pub fn populate_frame(framesize: FrameSize, data: ToBeDisplayed) {
//     let columns = generate_columns_from_lines(&data.lines);
//     for photon in data.data0.iter() {
//         let row = bisect_right(&data.lines.as_slice(), photon) - 1;
//         let relative_to_column = photon - data.lines.index(row);
//         let column = bisect_right(&columns.as_slice(), &relative_to_column);
//     }

// }

// pub fn generate_columns_from_lines(lines: &ArrivalTimes, scan_phase: u64) -> ArrivalTimes {
//     let diff_len = lines.nrows() - 1;
//     let diff = lines.rows(1, diff_len) - lines.rows(0, diff_len);
//     let min = diff.min();
//     let max = diff.max();
//     let columns = DVector
// }
//

#[repr(C)]
#[derive(Debug, Clone)]
pub(crate) struct Tag {
    type_: u8,
    missed_events: u16,
    channel: i32,
    time: i64,
}

impl Tag {
    pub(crate) unsafe fn from_ptr(ptr: *const u8) {
        let record_as_slice = std::slice::from_raw_parts(&ptr, ITEMSIZE);
        let type_ = u8::from_le_bytes(record_as_slice[0..1]);
    }
}

#[derive(Debug, Clone)]
pub(crate) struct IncomingTags(Vec<Tag>);

fn print_tags(len: usize, type_: MatrixSlice<u8, Dynamic, U1>, missed_events: MatrixSlice<u16, Dynamic, U1>, channel: MatrixSlice<i32, Dynamic, U1>, time: MatrixSlice<i64, Dynamic, U1>) {
    println!("{:?}", data_ptr);
}

#[pyfunction]
fn process_stream(py: Python, len: usize, type_: &PyObject, missed_events: &PyObject, channel: &PyObject, time: &PyObject) {
    let type_ = unsafe { matrix_slice_from_numpy::<u8, Dynamic, U1>(py, type_)};
    let missed_events = unsafe { matrix_slice_from_numpy::<u16, Dynamic, U1>(py, missed_events)};
    let channel = unsafe { matrix_slice_from_numpy::<i32, Dynamic, U1>(py, channel)};
    let time = unsafe { matrix_slice_from_numpy::<i64, Dynamic, U1>(py, time)};
    py.allow_threads(|| print_tags(len, type_, missed_events, channel, time));
}

#[pymodule]
fn librpysight(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_wrapped(wrap_pyfunction!(process_stream))?;
    Ok(())
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
